<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Winds_Trader"
   author="Areia"
   id="cfb5131348f00eca0684adce"
   language="Lua"
   purpose="Trade Winds cards"
   save_state="n"
   date_written="2021-11-08 12:00:00"
   requires="5.06"
   version="0.0"
   >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
</aliases>



<triggers>
</triggers>



<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "serialize"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")
dofile(GetInfo(60) .. "telnet_options.lua")



--------------------------------------------------
-- Config
--------------------------------------------------

Config = {}

function Config.initialize()
    Config.load()
end

function Config.default()
    local data = {
        ["created"] = false,
    }
    return serialize.save_simple(data)
end

function Config.load()
    local strvar = var.config or Config.default()
    local data = loadstring("return " .. strvar)()
    Config.data = data
end

function Config.save()
    var.config = serialize.save_simple(Config.data)
end

function Config.get(key)
    return Config.data[key]
end

function Config.set(key, val)
    Config.data[key] = val
    Config.save()
end
]]>
</script>



<aliases>
    <alias
     match="^winds\s+(?<action>remove|upload)\s+case(?<keyword>.*)$"
     enabled="y"
     script="Inv.identify"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+upload\s+cards(?<location>.*)$"
     enabled="y"
     script="Inv.inventory"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<triggers>
    <trigger
     name="trigger_inv_case_start"
     match="^You have (?:the following|no) cards stored[:.]$"
     enabled="n"
     script="Inv.case_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Keywords\s+:(?<keywords>.+)\|$"
     enabled="n"
     script="Inv.case_keywords"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Id\s+:(?<id>.+)\|$"
     enabled="n"
     script="Inv.case_id"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_case_end"
     group="triggerg_inv_case"
     match="^\{/(?<action>rm|up)case\}$"
     enabled="n"
     script="Inv.case_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
    
    <trigger
     name="trigger_inv_cards_start"
     group="triggerg_inv_cards"
     match="^(?:You are carrying|The .+ contains):$"
     enabled="n"
     script="Inv.cards_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_card"
     group="triggerg_inv_cards"
     match="^(?:\(\s*(?<count>\d+)\))?(?:\s+\([a-zA-Z ()]+\)) (?<name>\w+) Fantasy Series Collector's Card(?: \(201\))?$"
     enabled="n"
     script="Inv.cards_card"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_end"
     group="triggerg_inv_cards"
     match="^\{/inv\}$"
     enabled="n"
     script="Inv.cards_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
</triggers>

<script>
<![CDATA[
--------------------------------------------------
-- Inv
--------------------------------------------------

Inv = {}

function Inv.initialize()
    Inv.clear_data()
end

function Inv.clear_data()
    Inv.case = {}
    Inv.cards = {}
end

function Inv.identify(alias, line, wc)
    local action = wc.action
    local keyword = trim(wc.keyword)
    if (keyword == "") then
        Utility.msg_prim(string.format("%s what case?", Utility.pascal_case(action)))
        return
    end
    
    Inv.clear_data()
    EnableTrigger("trigger_inv_case_start", true)
    EnableTrigger("trigger_inv_case_end", true)
    SendNoEcho("identify " .. keyword)
    -- Rezit decided to add a blank line between stored list and identify output,
    -- so add an ending echo of our own...
    local shortAction = action:lower() == "upload" and "up" or "rm"
    local endTag = string.format("echo {/%scase}", shortAction)
SendNoEcho(endTag)
end

function Inv.case_start(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", true)
end

function Inv.case_keywords(trigger, line, wc)
--[===[ This original code inserts simply the case keywords. API requires full
        lines, but keeping this here in case it's ever useful.
    Inv.case.keywords = trim(wc.keywords)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_id(trigger, line, wc)
--[===[ Ditto
    Inv.case.id = trim(wc.id)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_end(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", false)
    if (wc.action == "up") then
        Remote.upload_case()
    elseif (wc.action == "rm") then
        Remote.remove_case()
    end
end

function Inv.inventory(alias, line, wc)
    Inv.clear_data()
    local location = trim(wc.location)
    EnableTrigger("trigger_inv_cards_start", true)
    EnableTrigger("trigger_inv_cards_end", true)
    TelnetOptionOff(TELOPT_PAGING) -- Temporarily disable paging if it is on
    if (location == "") then
        SendNoEcho("inventory")
    else
        SendNoEcho("look in " .. location)
    end
    SendNoEcho("echo {/inv}")
    TelnetOptionOn(TELOPT_PAGING) -- Re-enable paging if it was on
end

function Inv.cards_start(trigger, line, wc)
    EnableTrigger("trigger_inv_cards_start", false)
    EnableTrigger("trigger_inv_cards_card", true)
end

function Inv.cards_card(trigger, line, wc)
--[===[ This original code inserts simply the card names. API requires full
        lines, but keeping this here in case it's ever useful.
    local count = tonumber(wc.count) or 1
    local name = wc.name
    for i = 1, count do
        table.insert(Inv.cards, name)
    end
]===]
    table.insert(Inv.cards, line)
end

function Inv.cards_end(trigger, line, wc)
    EnableTriggerGroup("triggerg_inv_cards", false)
    if (#Inv.cards > 0) then
        table.sort(Inv.cards)
    end
    Remote.upload_cards()
end
]]>
</script>



<script>
<![CDATA[
local https = require "ssl.https"
require "json"
local ltn12 = require "ltn12"

--------------------------------------------------
-- Remote
--------------------------------------------------

Remote = {}

function Remote.initialize()
    Remote.API = "https://winds.aarderik.nl/api.php/p/"
end

function Remote.get(url)
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "GET",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
        },
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(response[1])
    end
    return nil
end

function Remote.post(url, data)
    data = data or ""
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "POST",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
            ["Content-Length"] = #data,
        },
        ["source"] = ltn12.source.string(data),
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(response[1])
    end
    return nil
end

function Remote.create_char(name)
    if (not name) then
        Utility.msg_prim("Character creation failed. No name given.")
        return false
    end
    
    name = trim(name)
    if (name == "") then
        Utility.msg_prim("Character creation failed. No name given.")
        return false
    end
    
    local url = string.format("%s%s/create", Remote.API, name)
    Utility.msg_prim(string.format("Creating character %s...", name))
    local response = Remote.post(url)
    if not (response and response.success) then
        Utility.msg_prim("Character creation failed. Server error.")
        return false
    end
    
    Utility.msg_prim(string.format("Character creation for %s succeeded.", name))
    return true
end

function Remote.char_exists(name)
    -- Ensure char exists before trying to send/get any data. If it does not
    -- exist, we create it.
    local exists = true
    if not (Config.get("created") or Remote.create_char(name)) then
        exists = false
    end
    Config.set("created", exists)
    return exists
end

function Remote.upload_cards()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload cards. GMCP data not available.")
        return false
    end
    
    if (#Inv.cards == 0) then
        Utility.msg_prim("No extra cards found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload cards.")
        return false
    end
    
    local url = string.format("%s%s/upcard", Remote.API, name)
    local data = string.format("cards=%s", table.concat(Inv.cards, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload extra cards.")
        return false
    end
    
    -- Change `cards` to `card` in result message if quantity is 1...
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 1) then
        msg = msg:gsub("cards", "card")
    end
    
    Utility.msg_prim(msg)
    return true
end

function Remote.upload_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload case.")
        return false
    end
    
    local url = string.format("%s%s/upcase", Remote.API, name)
    local data = string.format("cases=%s", table.concat(Inv.case, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload case.")
        return false
    end
    
    -- Success can return `0 cases uploaded` if the case already exists. Change
    -- this message to something more user-friendly.
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 0) then
        msg = msg:gsub("0 cases", "1 case")
    end
    Utility.msg_prim(msg)
    return true
end

function Remote.remove_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to remove case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to remove case.")
        return false
    end
    
    local id = Inv.case[2]:match("%d+")
    local url = string.format("%s%s/rmcase/%s", Remote.API, name, id)
    local response = Remote.post(url)
    if not (response) then
        Utility.msg_prim("Failed to remove case.")
        return false
    end
    
    if (response.errstr) then
        Utility.msg_prim("No such case found.")
        return false
    end
    
    Utility.msg_prim(response.result)
    return true
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- GMCP
--------------------------------------------------

GMCP = {}

function GMCP.char_name()
    return gmcp("char.base.name")
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local modules = {
        Config,
        Inv,
        Remote,
    }
    for _, module in ipairs(modules) do
        if (module.initialize) then
            module.initialize()
        end
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.msg_prim(str, ...)
    Utility.print(string.format("[@YWinds Trader@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.second_msg(msg)
    end
end

function Utility.msg_sec(str)
    Utility.print(string.format("                %s", str))
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end

function Utility.ends_with(s, t)
    return Utility.starts_with(s:reverse(), t:reverse())
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginInstall()
    Utility.initialize()
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264") then
    end
end
]]>
</script>


</muclient>
