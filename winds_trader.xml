<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Winds_Trader"
   author="Areia"
   id="cfb5131348f00eca0684adce"
   language="Lua"
   purpose="Trade Winds cards"
   save_state="y"
   date_written="2021-11-08 12:00:00"
   requires="5.06"
   version="0.04"
   >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
    <alias
     match="^winds\s+config\s+limittrades\s+(?<daysAgo>[0-9-]+)$"
     enabled="y"
     script="Config.set_daysago"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "serialize"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")
dofile(GetInfo(60) .. "telnet_options.lua")



--------------------------------------------------
-- Config
--------------------------------------------------

Config = {}

function Config.initialize()
    Config.load()
end

function Config.default()
    local data = {
        ["created"] = false,
        ["daysAgo"] = 0,
    }
    return serialize.save_simple(data)
end

function Config.load()
    local strvar = var.config or Config.default()
    local data = loadstring("return " .. strvar)()
    Config.data = data
end

function Config.save()
    var.config = serialize.save_simple(Config.data)
end

function Config.get(key)
    return Config.data[key]
end

function Config.set(key, val)
    Config.data[key] = val
    Config.save()
end

function Config.set_daysago(alias, line, wc)
    local daysAgo = tonumber(wc.daysAgo)
    daysAgo = daysAgo < 1 and 0 or daysAgo
    Config.set("daysAgo", daysAgo)
    if (daysAgo == 0) then
        Utility.msg_prim("Trade search not limited by player activity.")
    elseif (daysAgo == 1) then
        Utility.msg_prim("Trade search limited to players active in the last day.")
    else
        Utility.print(string.format(
            "Trade search limited to players active in the last %d days.",
            daysAgo
        ))
    end
end
]]>
</script>



<aliases>
    <!-- sequence 101 to evaluate after card upload alias -->
    <alias
     match="^winds\s+(?<action>remove|upload)(?<keyword>.*)$"
     enabled="y"
     script="Inv.identify"
     regexp="y"
     ignore_case="y"
     sequence="101"
    >
    </alias>
    <alias
     match="^winds\s+upload\s+cards(?<location>.*)$"
     enabled="y"
     script="Inv.inventory"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+remove\s+card(?<card>.*)$"
     enabled="y"
     script="Inv.remove_card"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<triggers>
    <trigger
     name="trigger_inv_case_start"
     match="^You have (?:the following|no) cards stored[:.]$"
     enabled="n"
     script="Inv.case_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Keywords\s+:(?<keywords>.+)\|$"
     enabled="n"
     script="Inv.case_keywords"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Id\s+:(?<id>.+)\|$"
     enabled="n"
     script="Inv.case_id"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_case_end"
     group="triggerg_inv_case"
     match="^\{/(?<action>rm|up)case\}$"
     enabled="n"
     script="Inv.case_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
    
    <trigger
     name="trigger_inv_cards_start"
     group="triggerg_inv_cards"
     match="^(?:You are carrying|The .+ contains):$"
     enabled="n"
     script="Inv.cards_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_card"
     group="triggerg_inv_cards"
     match="^(?:\(\s*(?<count>\d+)\))?(?:\s+\([a-zA-Z ()]+\)) (?<name>\w+) Fantasy Series Collector's Card(?: \(201\))?$"
     enabled="n"
     script="Inv.cards_card"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_end"
     group="triggerg_inv_cards"
     match="^\{/inv\}$"
     enabled="n"
     script="Inv.cards_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
</triggers>

<script>
<![CDATA[
--------------------------------------------------
-- Inv
--------------------------------------------------

Inv = {}

function Inv.initialize()
    Inv.clear_data()
end

function Inv.clear_data()
    Inv.case = {}
    Inv.cards = {}
end

function Inv.identify(alias, line, wc)
    local action = wc.action
    local keyword = trim(wc.keyword)
    if (keyword == "") then
        Utility.msg_prim(string.format("%s what case?", Utility.pascal_case(action)))
        return
    end
    
    Inv.clear_data()
    EnableTrigger("trigger_inv_case_start", true)
    EnableTrigger("trigger_inv_case_end", true)
    SendNoEcho("identify " .. keyword)
    -- Rezit decided to add a blank line between stored list and identify output,
    -- so add an ending echo of our own...
    local shortAction = action:lower() == "upload" and "up" or "rm"
    local endTag = string.format("echo {/%scase}", shortAction)
SendNoEcho(endTag)
end

function Inv.case_start(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", true)
end

function Inv.case_keywords(trigger, line, wc)
--[===[ This original code inserts simply the case keywords. API requires full
        lines, but keeping this here in case it's ever useful.
    Inv.case.keywords = trim(wc.keywords)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_id(trigger, line, wc)
--[===[ Ditto
    Inv.case.id = trim(wc.id)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_end(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", false)
    if (wc.action == "up") then
        Remote.upload_case()
    elseif (wc.action == "rm") then
        Remote.remove_case()
    end
end

function Inv.inventory(alias, line, wc)
    Inv.clear_data()
    local location = trim(wc.location)
    EnableTrigger("trigger_inv_cards_start", true)
    EnableTrigger("trigger_inv_cards_end", true)
    TelnetOptionOff(TELOPT_PAGING) -- Temporarily disable paging if it is on
    if (location == "") then
        SendNoEcho("inventory")
    else
        SendNoEcho("look in " .. location)
    end
    SendNoEcho("echo {/inv}")
    TelnetOptionOn(TELOPT_PAGING) -- Re-enable paging if it was on
end

function Inv.cards_start(trigger, line, wc)
    EnableTrigger("trigger_inv_cards_start", false)
    EnableTrigger("trigger_inv_cards_card", true)
end

function Inv.cards_card(trigger, line, wc)
--[===[ This original code inserts simply the card names. API requires full
        lines, but keeping this here in case it's ever useful.
    local count = tonumber(wc.count) or 1
    local name = wc.name
    for i = 1, count do
        table.insert(Inv.cards, name)
    end
]===]
    table.insert(Inv.cards, line)
end

function Inv.cards_end(trigger, line, wc)
    EnableTriggerGroup("triggerg_inv_cards", false)
    if (#Inv.cards > 0) then
        table.sort(Inv.cards)
    end
    Remote.upload_cards()
end

function Inv.remove_card(trigger, line, wc)
    local card = trim(wc.card)
    if (card == "") then
        Utility.msg_prim("Remove which card?")
        return
    end
    
    Remote.remove_card(card)
end
]]>
</script>


<aliases>
    <alias
     match="^winds\s+forcecreate$"
     enabled="y"
     script="Remote.force_create"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+trades\s+(?<cases>\d+)(?<with>\s+\w+)?$"
     enabled="y"
     script="Remote.display_trades"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+update$"
     enabled="y"
     script="Remote.update_plugin"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
local https = require "ssl.https"
require "json"
local ltn12 = require "ltn12"

--------------------------------------------------
-- Remote
--------------------------------------------------

Remote = {}

function Remote.initialize()
    Remote.API = "https://winds.aarderik.nl/api.php/p/"
end

function Remote.get(url)
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "GET",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
        },
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(table.concat(response, ""))
    end
    return nil
end

function Remote.post(url, data)
    data = data or ""
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "POST",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
            ["Content-Length"] = #data,
        },
        ["source"] = ltn12.source.string(data),
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(table.concat(response, ""))
    end
    return nil
end

function Remote.create_char(name)
    local success = false
    if (not name) then
        Utility.msg_prim("Character creation failed. No name given.")
        Config.set("created", success)
        return success
    end
    
    name = trim(name)
    if (name == "") then
        Utility.msg_prim("Character creation failed. No name given.")
        Config.set("created", success)
        return success
    end
    
    local url = string.format("%s%s/create", Remote.API, name)
    Utility.msg_prim(string.format("Creating character %s...", name))
    local response = Remote.post(url)
    if not (response and response.success) then
        Utility.msg_prim("Character creation failed. Server error.")
        Config.set("created", success)
        return success
    end
    
    success = true
    Config.set("created", success)
    Utility.msg_prim(string.format("Character creation for %s succeeded.", name))
    return success
end

function Remote.char_exists(name)
    -- Ensure char exists before trying to send/get any data. If it does not
    -- exist, we create it.
    local exists = true
    if not (Config.get("created") or Remote.create_char(name)) then
        exists = false
    end
    return exists
end

function Remote.force_create(alias, line, wc)
    local name = GMCP.char_name()
    Config.set("created", false)
    Remote.create_char(name)
end

function Remote.upload_cards()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload cards. GMCP data not available.")
        return false
    end
    
    if (#Inv.cards == 0) then
        Utility.msg_prim("No extra cards found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload cards.")
        return false
    end
    
    local url = string.format("%s%s/upcard", Remote.API, name)
    local data = string.format("cards=%s", table.concat(Inv.cards, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload extra cards.")
        return false
    end
    
    -- Change `cards` to `card` in result message if quantity is 1...
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 1) then
        msg = msg:gsub("cards", "card")
    end
    
    Utility.msg_prim(msg)
    Remote.offer_trades()
    return true
end

function Remote.remove_card(card)
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to remove cards. GMCP data not available.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to remove cards.")
        return false
    end
    
    local url = string.format("%s%s/rmcard/%s", Remote.API, name, card)
    local response = Remote.post(url)
    if not (response) then
        Utility.msg_prim("Failed to remove card.")
        return false
    end
    
    if (response.errstr) then
        local msg = response.errstr:gsub("rmcard: ", "")
        Utility.msg_prim(msg)
        return false
    end
    
    Utility.msg_prim(response.result)
    Remote.offer_trades()
    return true
end

function Remote.upload_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload case.")
        return false
    end
    
    local url = string.format("%s%s/upcase", Remote.API, name)
    local data = string.format("cases=%s", table.concat(Inv.case, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload case.")
        return false
    end
    
    -- Success can return `0 cases uploaded` if the case already exists. Change
    -- this message to something more user-friendly.
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 0) then
        msg = msg:gsub("0 cases", "1 case")
    end
    Utility.msg_prim(msg)
    Remote.offer_trades()
    return true
end

function Remote.remove_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to remove case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to remove case.")
        return false
    end
    
    local id = Inv.case[2]:match("%d+")
    local url = string.format("%s%s/rmcase/%s", Remote.API, name, id)
    local response = Remote.post(url)
    if not (response) then
        Utility.msg_prim("Failed to remove case.")
        return false
    end
    
    if (response.errstr) then
        Utility.msg_prim("No such case found.")
        return false
    end
    
    Utility.msg_prim(response.result)
    Remote.offer_trades()
    return true
end

function Remote.display_trades(alias, line, wc)
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to retrieve trades. GMCP data not available.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to retrieve trades.")
        return false
    end
    
    local cases = wc.cases
    local url = string.format("%s%s/trades/%s", Remote.API, name, cases)
    local with = trim(wc.with)
    if (with ~= "") then
        url = string.format("%s?with=%s", url, with)
    else
        local daysAgo = Config.get("daysAgo")
        if (daysAgo > 0) then
            url = string.format("%s?days_ago=%d", url, daysAgo)
        end
    end
    
    local response = Remote.get(url)
    if (not response) then
        Utility.msg_prim("Failed to retrieve trades.")
        return false
    end
    
    if (response.errstr) then
        local msg = response.errstr:gsub("trades: ", "")
        Utility.msg_prim(msg)
        return false
    end
    
    local cases = response.cases
    table.sort(cases)
    local caseDisplayed = false
    for caseNum, caseInfo in pairs(cases) do
        caseDisplayed = true
        local header = string.format("@WTrades for case%d (@Y%s@W)", caseNum, caseInfo.name)
        local headerIndent = math.floor((80 - #strip_colours(header)) / 2)
        Utility.print(string.format("%s%s", string.rep(" ", headerIndent), header))
        
        -- Collect player names so we can display them alphabetically
        local players = {}
        for player, trades in pairs(caseInfo.trades) do
            table.insert(players, player)
        end
        table.sort(players)
        
        -- Now run through each player and display their trades (if any)
        for _, player in ipairs(players) do
            local updated = caseInfo.trades[player].updated or "N/A"
            local give = Utility.remove_duplicates(caseInfo.trades[player].give)
            local recv = Utility.remove_duplicates(caseInfo.trades[player].recv)
            -- Display only players who can either give or receive cards
            if (#give > 0 or #recv > 0) then
                Utility.print(string.format("@W%s @w(%s):", player, updated))
                if (#give > 0) then
                    Utility.print(string.format("   @YNeeds@w: %s", table.concat(give, ", ")))
                end -- can give
                if (#recv > 0) then
                    Utility.print(string.format("   @YHas  @w: %s", table.concat(recv, ", ")))
                end -- can receive
            end -- can either give or receive
        end -- for each player
    end -- for each case
    
    if (not caseDisplayed) then
        Utility.msg_prim("NO trades available.")
    end
    
    return true
end

function Remote.update_plugin(alias, line, wc)
    local url = "https://raw.githubusercontent.com/AreiaAard/Winds_Trader/main/winds_trader.xml"
    local xml = https.request(url)
    if (not xml) then
        Utility.msg_prim("Failed to download remote plugin file.")
        return false
    end
    
    local pluginID = GetPluginID()
    local localVersion = GetPluginInfo(pluginID, 19) or 0
    local localVersionStr = string.format("%1.2f", localVersion)
    local remoteVersionStr = xml:match('%s%s+version="([0-9%.]+)"')
    local remoteVersion = tonumber(remoteVersionStr or "") or 0
    
    if (localVersion == remoteVersion) then
        Utility.msg_prim("Version is up to date.")
        return true
    end
    
    Utility.msg_prim(string.format("Updating from v%s to v%s...",
        localVersionStr, remoteVersionStr
    ))
    Utility.msg_sec("Please do not touch anything.")
    local fileName = GetPluginInfo(pluginID, 6)
    local file = assert(io.open(fileName, "w"))
    file:write(xml)
    file:close()
    Utility.reload_plugin()
    return true
end

function Remote.offer_trades()
    local name = GMCP.char_name()
    if (not name or name == "") then
        return false
    end
    
    local action = "https://winds.aarderik.nl/index.php?player=" .. name
    local text = "here"
    local hint = "Open " .. action
    local fgPlain = "silver"
    local fgHighlight = "yellow"
    local bg = "black"
    local url = true
    local noUnderline = false
    local indent = string.rep(" ", 16)
    Tell(indent)
     ColourTell(fgPlain, bg, "Click ")
    Hyperlink(action, text, hint, fgHighlight, bg, url, noUnderline)
    ColourTell("silver", "black", " to view your trades on the trading site.")
    Note("")
    
    action = "winds trades 1234"
    text = "winds trades <cases>"
    hint = "View trades here"
    url = false
    Tell(indent)
    ColourTell(fgPlain, bg, "Or submit ")
    Hyperlink(action, text, hint, fgHighlight, bg, url, noUnderline)
    ColourTell(fgPlain, bg, " to view trades here.")
    Note("")
    
    return true
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- GMCP
--------------------------------------------------

GMCP = {}

function GMCP.char_name()
    return gmcp("char.base.name")
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local modules = {
        Config,
        Inv,
        Remote,
    }
    for _, module in ipairs(modules) do
        if (module.initialize) then
            module.initialize()
        end
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.msg_prim(str, ...)
    Utility.print(string.format("[@YWinds Trader@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.second_msg(msg)
    end
end

function Utility.msg_sec(str)
    Utility.print(string.format("                %s", str))
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end

function Utility.ends_with(s, t)
    return Utility.starts_with(s:reverse(), t:reverse())
end

function Utility.remove_duplicates(t)
    local found = {}
    local new = {}
    for k, v in ipairs(t) do
        if (not found[v]) then
        found[v] = true
        table.insert(new, v)
        end
    end
    return new
end

function Utility.reload_plugin()
    if (GetAlphaOption("script_prefix") == "") then
        SetAlphaOption("script_prefix", "\\\\\\")
    end
    local scriptPrefix = GetAlphaOption("script_prefix")
    local pluginID = GetPluginID()
    local cmd = "%sDoAfterSpecial(1, \"ReloadPlugin('%s')\", sendto.script)"
    Utility.msg_prim("Reloading...")
    Execute(cmd:format(scriptPrefix, pluginID))
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginInstall()
    Utility.initialize()
    Utility.msg_prim("Plugin installed. Submit @Ywinds help @wfor usage.")
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264") then
    end
end
]]>
</script>


</muclient>
