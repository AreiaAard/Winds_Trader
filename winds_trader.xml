<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Winds_Trader"
   author="Areia"
   id="cfb5131348f00eca0684adce"
   language="Lua"
   purpose="Trade Winds cards"
   save_state="y"
   date_written="2021-11-08 12:00:00"
   requires="5.06"
   version="0.05"
   >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
    <alias
     match="^winds\s+config\s+limittrades\s+(?<daysAgo>[0-9-]+)$"
     enabled="y"
     script="Config.set_daysago"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "serialize"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")
dofile(GetInfo(60) .. "telnet_options.lua")



--------------------------------------------------
-- Config
--------------------------------------------------

Config = {}

function Config.initialize()
    Config.load()
end

function Config.default()
    local data = {
        ["created"] = false,
        ["daysAgo"] = 0,
    }
    return serialize.save_simple(data)
end

function Config.load()
    local strvar = var.config or Config.default()
    local data = loadstring("return " .. strvar)()
    Config.data = data
end

function Config.save()
    var.config = serialize.save_simple(Config.data)
end

function Config.get(key)
    return Config.data[key]
end

function Config.set(key, val)
    Config.data[key] = val
    Config.save()
end

function Config.set_daysago(alias, line, wc)
    local daysAgo = tonumber(wc.daysAgo)
    daysAgo = daysAgo < 1 and 0 or daysAgo
    Config.set("daysAgo", daysAgo)
    if (daysAgo == 0) then
        Utility.msg_prim("Trade search not limited by player activity.")
    elseif (daysAgo == 1) then
        Utility.msg_prim("Trade search limited to players active in the last day.")
    else
        Utility.print(string.format(
            "Trade search limited to players active in the last %d days.",
            daysAgo
        ))
    end
end
]]>
</script>



<aliases>
    <!-- sequence 101 to evaluate after card upload alias -->
    <alias
     match="^winds\s+(?<action>remove|upload)(?<keyword>.*)$"
     enabled="y"
     script="Inv.identify"
     regexp="y"
     ignore_case="y"
     sequence="101"
    >
    </alias>
    <alias
     match="^winds\s+upload\s+cards(?<location>.*)$"
     enabled="y"
     script="Inv.inventory"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+remove\s+card(?<card>.*)$"
     enabled="y"
     script="Inv.remove_card"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<triggers>
    <trigger
     name="trigger_inv_case_start"
     match="^You have (?:the following|no) cards stored[:.]$"
     enabled="n"
     script="Inv.case_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Keywords\s+:(?<keywords>.+)\|$"
     enabled="n"
     script="Inv.case_keywords"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     group="triggerg_inv_case"
     match="^\|\s+Id\s+:(?<id>.+)\|$"
     enabled="n"
     script="Inv.case_id"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_case_end"
     group="triggerg_inv_case"
     match="^\{/(?<action>rm|up)case\}$"
     enabled="n"
     script="Inv.case_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
    
    <trigger
     name="trigger_inv_cards_start"
     group="triggerg_inv_cards"
     match="^(?:You are carrying|The .+ contains):$"
     enabled="n"
     script="Inv.cards_start"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_card"
     group="triggerg_inv_cards"
     match="^(?:\(\s*(?<count>\d+)\))?(?:\s+\([a-zA-Z ()]+\)) (?<name>\w+) Fantasy Series Collector's Card(?: \(201\))?$"
     enabled="n"
     script="Inv.cards_card"
     regexp="y"
     sequence="100"
    >
    </trigger>
    <trigger
     name="trigger_inv_cards_end"
     group="triggerg_inv_cards"
     match="^\{/inv\}$"
     enabled="n"
     script="Inv.cards_end"
     regexp="y"
     omit_from_output="y"
     sequence="100"
    >
    </trigger>
</triggers>

<script>
<![CDATA[
--------------------------------------------------
-- Inv
--------------------------------------------------

Inv = {}

function Inv.initialize()
    Inv.clear_data()
end

function Inv.clear_data()
    Inv.case = {}
    Inv.cards = {}
end

function Inv.identify(alias, line, wc)
    local action = wc.action
    local keyword = trim(wc.keyword)
    if (keyword == "") then
        Utility.msg_prim(string.format("%s what case?", Utility.pascal_case(action)))
        return
    end
    
    Inv.clear_data()
    EnableTrigger("trigger_inv_case_start", true)
    EnableTrigger("trigger_inv_case_end", true)
    SendNoEcho("identify " .. keyword)
    -- Rezit decided to add a blank line between stored list and identify output,
    -- so add an ending echo of our own...
    local shortAction = action:lower() == "upload" and "up" or "rm"
    local endTag = string.format("echo {/%scase}", shortAction)
SendNoEcho(endTag)
end

function Inv.case_start(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", true)
end

function Inv.case_keywords(trigger, line, wc)
--[===[ This original code inserts simply the case keywords. API requires full
        lines, but keeping this here in case it's ever useful.
    Inv.case.keywords = trim(wc.keywords)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_id(trigger, line, wc)
--[===[ Ditto
    Inv.case.id = trim(wc.id)
]===]
    table.insert(Inv.case, line)
end

function Inv.case_end(trigger, line, wc)
    EnableTrigger("trigger_inv_case_start", false)
    EnableTriggerGroup("triggerg_inv_case", false)
    if (wc.action == "up") then
        Remote.upload_case()
    elseif (wc.action == "rm") then
        Remote.remove_case()
    end
end

function Inv.inventory(alias, line, wc)
    Inv.clear_data()
    local location = trim(wc.location)
    EnableTrigger("trigger_inv_cards_start", true)
    EnableTrigger("trigger_inv_cards_end", true)
    TelnetOptionOff(TELOPT_PAGING) -- Temporarily disable paging if it is on
    if (location == "") then
        SendNoEcho("inventory")
    else
        SendNoEcho("look in " .. location)
    end
    SendNoEcho("echo {/inv}")
    TelnetOptionOn(TELOPT_PAGING) -- Re-enable paging if it was on
end

function Inv.cards_start(trigger, line, wc)
    EnableTrigger("trigger_inv_cards_start", false)
    EnableTrigger("trigger_inv_cards_card", true)
end

function Inv.cards_card(trigger, line, wc)
--[===[ This original code inserts simply the card names. API requires full
        lines, but keeping this here in case it's ever useful.
    local count = tonumber(wc.count) or 1
    local name = wc.name
    for i = 1, count do
        table.insert(Inv.cards, name)
    end
]===]
    table.insert(Inv.cards, line)
end

function Inv.cards_end(trigger, line, wc)
    EnableTriggerGroup("triggerg_inv_cards", false)
    if (#Inv.cards > 0) then
        table.sort(Inv.cards)
    end
    Remote.upload_cards()
end

function Inv.remove_card(trigger, line, wc)
    local card = trim(wc.card)
    if (card == "") then
        Utility.msg_prim("Remove which card?")
        return
    end
    
    Remote.remove_card(card)
end
]]>
</script>


<aliases>
    <alias
     match="^winds\s+forcecreate$"
     enabled="y"
     script="Remote.force_create"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+trades\s+(?<cases>\d+)(?<with>\s+\w+)?$"
     enabled="y"
     script="Remote.display_trades"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+update$"
     enabled="y"
     script="Remote.update_plugin"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
local https = require "ssl.https"
require "json"
local ltn12 = require "ltn12"

--------------------------------------------------
-- Remote
--------------------------------------------------

Remote = {}

function Remote.initialize()
    Remote.API = "https://winds.aarderik.nl/api.php/p/"
end

function Remote.get(url)
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "GET",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
        },
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(table.concat(response, ""))
    end
    return nil
end

function Remote.post(url, data)
    data = data or ""
    local response = {}
    local ret, code, headers, status = https.request{
        ["url"] = url,
        ["method"] = "POST",
        ["headers"] = {
            ["Content-Type"] = "application/x-www-form-urlencoded",
            ["Content-Length"] = #data,
        },
        ["source"] = ltn12.source.string(data),
        ["sink"] = ltn12.sink.table(response)
    }
    if (response[1]) then -- Got response
        return json.decode(table.concat(response, ""))
    end
    return nil
end

function Remote.create_char(name)
    local success = false
    if (not name) then
        Utility.msg_prim("Character creation failed. No name given.")
        Config.set("created", success)
        return success
    end
    
    name = trim(name)
    if (name == "") then
        Utility.msg_prim("Character creation failed. No name given.")
        Config.set("created", success)
        return success
    end
    
    local url = string.format("%s%s/create", Remote.API, name)
    Utility.msg_prim(string.format("Creating character %s...", name))
    local response = Remote.post(url)
    if not (response and response.success) then
        Utility.msg_prim("Character creation failed. Server error.")
        Config.set("created", success)
        return success
    end
    
    success = true
    Config.set("created", success)
    Utility.msg_prim(string.format("Character creation for %s succeeded.", name))
    return success
end

function Remote.char_exists(name)
    -- Ensure char exists before trying to send/get any data. If it does not
    -- exist, we create it.
    local exists = true
    if not (Config.get("created") or Remote.create_char(name)) then
        exists = false
    end
    return exists
end

function Remote.force_create(alias, line, wc)
    local name = GMCP.char_name()
    Config.set("created", false)
    Remote.create_char(name)
end

function Remote.upload_cards()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload cards. GMCP data not available.")
        return false
    end
    
    if (#Inv.cards == 0) then
        Utility.msg_prim("No extra cards found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload cards.")
        return false
    end
    
    local url = string.format("%s%s/upcard", Remote.API, name)
    local data = string.format("cards=%s", table.concat(Inv.cards, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload extra cards.")
        return false
    end
    
    -- Change `cards` to `card` in result message if quantity is 1...
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 1) then
        msg = msg:gsub("cards", "card")
    end
    
    Utility.msg_prim(msg)
    Remote.offer_trades()
    return true
end

function Remote.remove_card(card)
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to remove cards. GMCP data not available.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to remove cards.")
        return false
    end
    
    local url = string.format("%s%s/rmcard/%s", Remote.API, name, card)
    local response = Remote.post(url)
    if not (response) then
        Utility.msg_prim("Failed to remove card.")
        return false
    end
    
    if (response.errstr) then
        local msg = response.errstr:gsub("rmcard: ", "")
        Utility.msg_prim(msg)
        return false
    end
    
    Utility.msg_prim(response.result)
    Remote.offer_trades()
    return true
end

function Remote.upload_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to upload case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to upload case.")
        return false
    end
    
    local url = string.format("%s%s/upcase", Remote.API, name)
    local data = string.format("cases=%s", table.concat(Inv.case, "\n")) 
    local response = Remote.post(url, data)
    if not (response and response.success) then
        Utility.msg_prim("Failed to upload case.")
        return false
    end
    
    -- Success can return `0 cases uploaded` if the case already exists. Change
    -- this message to something more user-friendly.
    local msg = response.result
    local quantity = tonumber(msg:match("^(%d+)"))
    if (quantity == 0) then
        msg = msg:gsub("0 cases", "1 case")
    end
    Utility.msg_prim(msg)
    Remote.offer_trades()
    return true
end

function Remote.remove_case()
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to remove case. GMCP data not available.")
        return false
    end
    
    -- Two lines required. First must show the item to be a Winds case.
    local keywordMatch = "case collector[1-4] %d+ %d+ NO_RESTRING"
    if (#Inv.case < 2 or not Inv.case[1]:match(keywordMatch)) then
        Utility.msg_prim("No Winds case found.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to remove case.")
        return false
    end
    
    local id = Inv.case[2]:match("%d+")
    local url = string.format("%s%s/rmcase/%s", Remote.API, name, id)
    local response = Remote.post(url)
    if not (response) then
        Utility.msg_prim("Failed to remove case.")
        return false
    end
    
    if (response.errstr) then
        Utility.msg_prim("No such case found.")
        return false
    end
    
    Utility.msg_prim(response.result)
    Remote.offer_trades()
    return true
end

function Remote.display_trades(alias, line, wc)
    local name = GMCP.char_name()
    if (not name or name == "") then
        Utility.msg_prim("Unable to retrieve trades. GMCP data not available.")
        return false
    end
    
    if (not Remote.char_exists(name)) then
        Utility.msg_prim("Unable to retrieve trades.")
        return false
    end
    
    local cases = wc.cases
    local url = string.format("%s%s/trades/%s", Remote.API, name, cases)
    local with = trim(wc.with)
    if (with ~= "") then
        url = string.format("%s?with=%s", url, with)
    else
        local daysAgo = Config.get("daysAgo")
        if (daysAgo > 0) then
            url = string.format("%s?days_ago=%d", url, daysAgo)
        end
    end
    
    local response = Remote.get(url)
    if (not response) then
        Utility.msg_prim("Failed to retrieve trades.")
        return false
    end
    
    if (response.errstr) then
        local msg = response.errstr:gsub("trades: ", "")
        Utility.msg_prim(msg)
        return false
    end
    
    local cases = response.cases
    table.sort(cases)
    local caseDisplayed = false
    for caseNum, caseInfo in pairs(cases) do
        caseDisplayed = true
        local header = string.format("@WTrades for case%d (@Y%s@W)", caseNum, caseInfo.name)
        local headerIndent = math.floor((80 - #strip_colours(header)) / 2)
        Utility.print(string.format("%s%s", string.rep(" ", headerIndent), header))
        
        -- Collect player names so we can display them alphabetically
        local players = {}
        for player, trades in pairs(caseInfo.trades) do
            table.insert(players, player)
        end
        table.sort(players)
        
        -- Now run through each player and display their trades (if any)
        for _, player in ipairs(players) do
            local updated = caseInfo.trades[player].updated or "N/A"
            local give = Utility.remove_duplicates(caseInfo.trades[player].give)
            local recv = Utility.remove_duplicates(caseInfo.trades[player].recv)
            -- Display only players who can either give or receive cards
            if (#give > 0 or #recv > 0) then
                Utility.print(string.format("@W%s @w(%s):", player, updated))
                if (#give > 0) then
                    Utility.print(string.format("   @YNeeds@w: %s", table.concat(give, ", ")))
                end -- can give
                if (#recv > 0) then
                    Utility.print(string.format("   @YHas  @w: %s", table.concat(recv, ", ")))
                end -- can receive
            end -- can either give or receive
        end -- for each player
    end -- for each case
    
    if (not caseDisplayed) then
        Utility.msg_prim("NO trades available.")
    end
    
    return true
end

function Remote.update_plugin(alias, line, wc)
    local url = "https://raw.githubusercontent.com/AreiaAard/Winds_Trader/main/winds_trader.xml"
    local xml = https.request(url)
    if (not xml) then
        Utility.msg_prim("Failed to download remote plugin file.")
        return false
    end
    
    local pluginID = GetPluginID()
    local localVersion = GetPluginInfo(pluginID, 19) or 0
    local localVersionStr = string.format("%1.2f", localVersion)
    local remoteVersionStr = xml:match('%s%s+version="([0-9%.]+)"')
    local remoteVersion = tonumber(remoteVersionStr or "") or 0
    
    if (localVersion == remoteVersion) then
        Utility.msg_prim("Version is up to date.")
        return true
    end
    
    Utility.msg_prim(string.format("Updating from v%s to v%s...",
        localVersionStr, remoteVersionStr
    ))
    Utility.msg_sec("Please do not touch anything.")
    local fileName = GetPluginInfo(pluginID, 6)
    local file = assert(io.open(fileName, "w"))
    file:write(xml)
    file:close()
    Utility.reload_plugin()
    return true
end

function Remote.offer_trades()
    local name = GMCP.char_name()
    if (not name or name == "") then
        return false
    end
    
    local action = "https://winds.aarderik.nl/index.php?player=" .. name
    local text = "here"
    local hint = "Open " .. action
    local fgPlain = "silver"
    local fgHighlight = "yellow"
    local bg = "black"
    local url = true
    local noUnderline = false
    local indent = string.rep(" ", 16)
    Tell(indent)
     ColourTell(fgPlain, bg, "Click ")
    Hyperlink(action, text, hint, fgHighlight, bg, url, noUnderline)
    ColourTell("silver", "black", " to view your trades on the trading site.")
    Note("")
    
    action = "winds trades 1234"
    text = "winds trades <cases>"
    hint = "View trades here"
    url = false
    Tell(indent)
    ColourTell(fgPlain, bg, "Or submit ")
    Hyperlink(action, text, hint, fgHighlight, bg, url, noUnderline)
    ColourTell(fgPlain, bg, " to view trades here.")
    Note("")
    
    return true
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- GMCP
--------------------------------------------------

GMCP = {}

function GMCP.char_name()
    return gmcp("char.base.name")
end
]]>
</script>



<aliases>
    <alias
     match="^winds\s+tradehelp$"
     enabled="y"
     script="Help.topics"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
    <alias
     match="^winds\s+tradehelp\s+(?<topic>\w+)$"
     enabled="y"
     script="Help.show_topic"
     regexp="y"
     ignore_case="y"
     sequence="100"
    >
    </alias>
</aliases>

<script>
<![CDATA[
--------------------------------------------------
-- Help
--------------------------------------------------

Help = {}

function Help.topics()
    local topics = {
        {name="config", desc="Configuring the plugin"},
        {name="upload", desc="Uploading cases and cards"},
        {name="remove", desc="Removing cases and cards"},
        {name="trades", desc="Displaying trades"},
        {name="misc", desc="Misc commands"},
    }
    
    local fgPlain = "silver"
    local fgHighlight = "yellow"
    local bg = "black"
    Utility.print("              @WWinds Trader Help -- Help Topics              ")
    Utility.print(string.rep("=", 60))
    for _, topic in ipairs(topics) do
        local action = "winds tradehelp " .. topic.name
        local text = "winds tradehelp " .. topic.name
        local hint = string.format("Show %s help", topic.name)
        Tell("  ")
        Hyperlink(action, text, hint, fgHighlight, bg, false)
        ColourTell(fgPlain, bg, ": ", fgPlain, bg, topic.desc)
        Note("")
    end
    Utility.print("Type or click on one of the above to show help.")
end

function Help.show_topic(alias, line, wc)
    local topics = {
        ["config"] = Help.config, ["upload"] = Help.upload,
        ["remove"] = Help.remove, ["trades"] = Help.trades,
        ["misc"] = Help.misc,
    }
    local function no_topic()
        Utility.msg_prim("No help topic with that name.")
        Help.topics()
    end
    
    local topic = string.lower(wc.topic)
    local func = topics[topic] or no_topic
    func()
end

function Help.config()
    Utility.print("                @WWinds Trader Help -- Config@w                ")
    Utility.print(string.rep("=", 60))
    local text = [[
    Syntax: @Ywinds config <config> <value>@w
This command sets configuration options for the plugin.
Available configs:
  limittrades: Limit display of trades to players active
    within the given number of days.
    Example: @Ywinds config limittrades 30 @w--> Show only
      players active within the last month.
    Example: @Ywinds config limittrades 0 @w--> Show trades
      with all players, regardless of activity.
]]
    Utility.print(text)
end

function Help.upload()
    Utility.print("                @WWinds Trader Help -- Upload@w                ")
    Utility.print(string.rep("=", 60))
    local text = [[
    Syntax: @Ywinds upload <case>@w
    Syntax: @Ywinds upload cards [location]@w
These commands allow you to upload your cases and cards to
the winds trading site.
To upload a case, have it in your inventory, and simply
type @Ywinds upload case@w. If you have more than one, you can
submit @Ywinds upload 2.case @wand so on.
To upload duplicate cards in your inventory, submit
@Ywinds upload cards@w. If your dupes are in a bag, simply type
@Ywinds upload cards <location> @w(e.g., 'backpack,' '2.bag,' or
container's id).
Uploading extra cards will completely replace the list of
duplicates saved on the site, so wherever you keep your
extras, be sure to keep them all in one place.
The plugin offers to show you trades after every upload
operation. You can click the links it provides for quick
access to your trades.
]]
    Utility.print(text)
end

function Help.remove()
    Utility.print("                @WWinds Trader Help -- Remove@w                ")
    Utility.print(string.rep("=", 60))
    local text = [[
    Syntax: @Ywinds remove <case>@w
    Syntax: @Ywinds remove card <card name>@w
If you complete a case, or trade away a duplicate, you will
want to remove it from your profile. these commands do just
that.
Case removal works similarly to case uploading. Ensure that
the case is in your inventory, and type, for example,
@Ywinds remove collector4@w.
Duplicate removal is currently done one-by-one. To remove
a Lasher card, you would type @Ywinds remove card lasher@w
(names are case-insensitive).
The plugin offers to show you trades after every remove
operation. You can click the links it provides for quick
access to your trades.
]]
    Utility.print(text)
end

function Help.trades()
    Utility.print("                @WWinds Trader Help -- Trades@w                ")
    Utility.print(string.rep("=", 60))
    local text = [[
    Syntax: @Ywinds trades <case number(s)> [player]@w
This command allows you to view your trades without having
to look on the trading site (although it's probably vis-
ually easier to do so).
Case numbers are 1 through 4 and refer to the cases for
which you wish to search trades. Typing @Ywinds trades 3@w
will display trades you can make with your case3 cards. It
is possible to view multiple cases at once. For example,
@Ywinds trades 14 @wshows trades for cases 1 and 4, and to see
all possible trades, you can submit @Ywinds trades 1234@w.
Adding a player's name at the end of the command will limit
your search to trades with only that particular player.
This can be useful if you develop a regular trading part-
ner, or simply to cut down on spam.
]]
    Utility.print(text)
end

function Help.misc()
    Utility.print("                 @WWinds Trader Help -- Misc@w                 ")
    Utility.print(string.rep("=", 60))
    local text = [[
Below are some various minor plugin commands which should
not necessarily be needed often.
  @Ywinds forcecreate@w: Forces the plugin to attempt to create
    a profile with your name. The plugin does this for you
    automatically, but in the case things get confused and
    the trading site forgets that you exist, you can try
    this.
  @Ywinds update@w: Checks for an updated version of the plugin
    and installs it if found.
]]
    Utility.print(text)
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local modules = {
        Config,
        Inv,
        Remote,
    }
    for _, module in ipairs(modules) do
        if (module.initialize) then
            module.initialize()
        end
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.msg_prim(str, ...)
    Utility.print(string.format("[@YWinds Trader@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.second_msg(msg)
    end
end

function Utility.msg_sec(str)
    Utility.print(string.format("                %s", str))
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end

function Utility.ends_with(s, t)
    return Utility.starts_with(s:reverse(), t:reverse())
end

function Utility.remove_duplicates(t)
    local found = {}
    local new = {}
    for k, v in ipairs(t) do
        if (not found[v]) then
        found[v] = true
        table.insert(new, v)
        end
    end
    return new
end

function Utility.reload_plugin()
    if (GetAlphaOption("script_prefix") == "") then
        SetAlphaOption("script_prefix", "\\\\\\")
    end
    local scriptPrefix = GetAlphaOption("script_prefix")
    local pluginID = GetPluginID()
    local cmd = "%sDoAfterSpecial(1, \"ReloadPlugin('%s')\", sendto.script)"
    Utility.msg_prim("Reloading...")
    Execute(cmd:format(scriptPrefix, pluginID))
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginInstall()
    Utility.initialize()
    Utility.msg_prim("Plugin installed. Submit @Ywinds tradehelp @wfor help topics.")
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264") then
    end
end
]]>
</script>


</muclient>
